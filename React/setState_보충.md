# setState 보충

**시작전 컨셉 복습** <br>

- 리액트는 변경사항이 한가지의 방향으로만 흘러간다.
- State&Props가 변경되면 리액트가 render()함수를 호출해서 UI가 업데이트된다

## 1 setState는 비동기 API

- webAPIs 중 하나인 setTimeout, setInterval과 같은 비동기 함수처럼, setState도 비동기 함수
  - 호출한다고 바로 호출되는게아니라 요청만 해놓고 뒤에 이어지는 코드 실행됨
  - 이러한 이유로 리액트가 동시다발적으로 요청된 여러가지 setState를 효율적으로 처리가능
  - 하지만, 언제 처리되는지 예측할 수 없고, 해당 state에서 그 이전의 값을 갖고있을 수 있으므로,
    state를 업데이트 할때 이전 state 값에서 무언가가 계산이 되어지는 경우라면,

```javascript
setState((prevState) => newState);
```

-> setState는 이전의 state를 기억하므로 이전 값을 받아와서 업데이트해주는게 좋다.

## 2 state를 직접 수정하면 안되는 이유

**리액트에서는 상태를 직접적으로 절대! 그 어떤 경우에도 절대! 수정하면 좋지 않다!!!!!** <br>

> 어떤 프로그래밍에서도 Object를 직접적으로 변경하는것은 좋지 않다. 이미 만들어진 Object는 항상 불변성(Immutability)를 유지하는것이 좋다.

-> 이유 1 : setState는 비동기적으로 동작한다.<br>
여러번 직접 수정하면서 업데이트하는경우, 이전 업데이트 내용이 다음 업데이트네용으로 덮어씌워질 수 있고 비동기 특성상 예상치 못한 곳에서 오류가 발생할 수 있다.<br>
-> PureComponent와 memo가 정상적으로 동작하지 않는다. <br>

shallow comparison을 통해 현재 컴포넌트가 가지고 있는 상태와 (this.state), 업데이트 해야 하는 새로운 상태 (setState 함수의 인자로 전달된 새로운 오브젝트)의 레퍼런스를 비교해서 업데이트가 필요한 경우 해당 컴포넌트의 render 함수를 호출하기때문
