# < Process & Thread >

<img src="https://user-images.githubusercontent.com/90666180/158095177-6ba8bc95-a446-4b29-bf12-ade735de1f16.jpg" width='500'>
<br/>
<br/>

# 1. Process

<br/>

### 1-1. 정의

- 운영체제 위에서 연속적으로 실행되고 있는 프로그램 ( 운영체제 위에서 독립적으로 메모리에서 실행되고 있는 프로그램)
- 프로그램을 동작하는 최고단위
- 그리고 각각의 프로세스마다 resource-자원들이 정해져있다. 즉, 프로세스마다 할당되어진 메모리나 데이터들이 지정되어져있다.

<br/>

### 1-2. 구성

- Code : 프로그램을 실행하기위한 코드
- Stack : 그 프로세스안에서 함수들이 어떤 순서로 실행되어야하는지 함수가 끝나고 돌아가는 지점에 대한 정보를 저장
- Heap : 오브젝트를 생성하거나, 데이터를 만들 때 데이터들이 저장되어지는 공간 , 동적으로 할당된 변수들이 저장
  (프로세스 내에서, 코드에서 관리되는 태스크 큐나 배열, 리스트 등 자료구조들은 HEAP 동적 메모리 영역에 할당)
- Data : 전역 변수나, 스태틱 변수들이 할당

<br/>
<br/>

# 2. Thread

<br/>

### 정의

- 한 프로세스안에서 여러개가 동작할 수 있는데, 쓰레드는 각각 저마다 해야되는 업무를 배정 받는다.<br/>
  (저마다 필요한 일들을 수행 즉,일꾼 단위!)<br/>
  그리고 프로세스에 지정된 코드와 데이터 힙들에게 공통적으로 접근해서 공통적으로 업데이트가 가능하다.<br/>
  ( 자신이 수행해야하는 함수의 호출을 기억해야하기 때문에 각각에 stack이 할당되어져있다.)
- 동시 다발적으로 발생할 수 있다. 따라서, 프로세스가 더 효율적으로 일할 수 있게 도움을 준다.
- 일의 흐름을 기억할 수 있는 고유의 스택이 각각 지정되어져있지만, 데이터, 코드, 힙 같은 공통적 데이터 리소스는 프로세스에 있기 때문에<br/>
  (즉 쓰레드들이 동시다발적으로 리소스에 접속해서 업데이트 해야하기에 )<br/>
  서로 공유하면서 사용한다. ⇒ multithreading
- 하나의 프로세스안에 여러개의 쓰레드가 존재할 수 있다.
  <br/>
  <br/>

## 2-1. 멀티쓰레딩(**multithreading**)

: 한 프로세스안에서 여러가지 쓰레드가 동시다발적으로 일어나는것, 효율적인 프로그래밍이가능

❖ JAVA언어에서는 언어 자체에서 멀티쓰레딩이 지원된다 ( 프로그래밍을 짤때 쓰레드를 지정 및 몇개의 쓰레드가 동시에 동작할지 등등을 구현할 수 있음)

  <br/>
  <br/>

## 2-2. 자바스크립트에서의 thread개념

- 자바스크립트는 Single Threaded Language : 언어자체에 멀티쓰레딩이 지원되지 않는다.
- 자바스크립트가 동작하고있는 브라우저 프로그램 안에서는 여러가지 쓰레드가 들어있다.<br/>
  (웹 APIs사용하게되면 멀티쓰레딩 가능)
- 자바스크립트가 동작하고 있는 실행 환경(런타임환경)에서는 다양한 방식을 이용해서 멀티쓰레딩 같은 효과를 얻을 수 있고, **이벤트 루프**를 통해서 조금 더 다양한 동작을 실행할 수 있다.

  <br/>
  <br/>

### 1) 자바스크립트 엔진

[구성] ⇒ [ **Memory Heap** ] + [**Call Stack**]

- Memory Heap : 데이터를 만들 때 해당 데이터들이 저장되는 장소<br/>
  (구조적으로 저장된 자료구조는 아니다

- Call Stack : 우리가 함수를 실행하는 순서에 따라 함수가 순서대로 쌓이는 장소, 함수들이 호출되는 순서를 기억했다가 함수가 끝나면 원래 있던 자리로 돌아가기 위해서 쓰이는 자료구조 중 하나로, 모든 프로세스와 쓰레드 안에는 각각 저마다의 콜스텍이 존재

⇒ 자바스크립트 런타임 환경에서는 사용자가 프로그램을 종료하지 않는 이상, 계속 실행되고 있는 상태이기 때문에 콜스텍이 비워져있다고 종료되지 않는다.

⇒ 자료구조 중 하나로 LIFO(리포; Last In First Out)라 할 수 있다.

⇒ 재귀함수

: 아래와같이 끝없이 함수 안에서 자기자신을 호출하기를 반복하는 함수로, 잘못사용하면 콜스텍의 용량을 초과했다는 에러가 발생

```javascript
function endless() {
  endless();
}
endless();
```

  <br/>
  <br/>

### 2) 자바스크립트 런타임 환경

  <br/>
  <br/>

<img src="https://user-images.githubusercontent.com/90666180/158096661-3b14f61d-b60c-4336-8a37-19fada396472.jpg"/>
  <br/>
  <br/>

- **Web APIs와 자바스크립트 엔진이 같이 동작하는 원리**

  - 대표적인 Web APIs : DOM API, setTimeout, setInterval, fetch, event listener

  1. Web API가 호출이되면 해당 API는 콜스텍에서 지워지고 콜백함수를 Task Queue에 등록

  - Queue : 자료구조중 하나, FIFO(First In First Out)구조
    (대표 API : add() , remove())

  2. Event Loop가 계속해서 돌면서 콜스택과 태스크큐를 체크 후 콜스텍의 일들이 비워질때까지 기다렸다가 콜스텍이 비워져 엔진이 아무런 일을 하지 않는 경우에 이벤트 루프에 있는 콜백을 콜스택으로 호출하며 실행된다

  - 즉, 이벤트 루프는: 프로세스가 동작하는 동안 루프를 순회하면서 콜 스텍이 비워져있다면 태스크 큐에 들어있는 콜백 하나를 콜스택으로 가져와서 자바스크립트 엔진이 수행할 수 있도록 도와준다.(테스크 큐에있는 콜백은 한번에 하나만 콜 스택으로 가져올 수 있다.)
    ❖ 참고 : [https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop](https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop)

<br/>

- **Task Queue**

  - 콜 스텍에서 지금 수행중인 콜백은 끝날때까지 보장이 된다.
    (즉, 그 중간에 다른 테스크나 다른 일들을 할 수 없고 지금 수행중인 코드 블럭이 끝날때 까지 이벤트 루프가 기다렸다가 다음에 다른 밑에 있는 콜스텍이 수행되거나 태스크 큐에 있는 콜백이 실행된다.)
  - MQ와 달리 TQ안의 콜백 하나를 콜스텍으로 보낸 후 콜스텍으로 와서 콜 스텍에있는 콜백이 다 끝날때까지 기다린 후 다시 순회

    <br/>

- **Microtask Queue ( 마이크로테스크 큐 )**

  - 프로미스에 등록된 콜백, 프로미스가 다 수행이 되고 나면 그 다음에 등록한 then에 등록한 콜백 함수, mutation observer에 등록된 콜백이 마이크로테스크 큐에 들어온다.
  - 마이크로테스크 큐에 있는 콜백들이 전부 차례차례 콜 스텍으로 넘어갈때까지 이벤트 루프는 MQ에 머물러있음
  - promise then
  - mutation observer

    <br/>

- **Render Sequence**

  - 매번이 아니고 주기적으로 우리가 브라우저에서 요소들을 움직이거나 애니메이션을 할 때 주기적으로 브라우저에 화면에 업데이트 해주는 것
  - 브라우저에서는 우리가 업데이트 하는 내용들을 사용자에게 60fps(16.7ms)의 프레임을 보여주도록 노력함 (즉, 16.7ms동안 업데이트를 해주기위해 노력)
  - 이벤트 루프가 순환하면서 다른일을 하다가 어느정도 시간이 되면 render 업데이트를하고 또 순회하는 구조
  - RequestAnimationFrame :
    - 이 API에는 우리가 등록한 콜백 함수가 나중에 브라우저에서 다음 렌더링이 발생하기 전에 해당 콜백이 수행되는 것을 보장
    - 브라우저 실행 전 콜백을 실행할 수 있는 API가 들어있음
    - 이벤트가 발생한 지점에는 코드를 수행하지 않아도되는데, 나중에 브라우저가 업데이트 되기 전에 해당 코드를 수행할때 사용
    - RequestAnimationFrame을통해 등록한 콜백은 RequestAnimationFrame Queue에 등록된다
  - 순서 RequestAnimationFrame → (RequestAnimationFrame API안의 Queue 있다면 순서대로 실행 적용 ) → Render Tree → Layout → Paint

    <br/>

    <br/>

예제1)

```jsx
const button = document.querySelector('button');
button.addEventListner('click', () => {
  const elem = document.createElement('h1');
  document.body.appendChild(elem);
  elem.style.color = 'red';
  elem.innerText = 'hello';
});
```

⇒ 이벤트리스너로 등록되어있는 콜백함수는 웹 APIs에서 클릭 이벤트가 발생하면 콜백을 테스크 큐로 전달.

⇒ 이벤트 루프가 테스크 큐에서 콜스택으로 전달, 그리고 스택에 들어간 순간 이벤트 루프는 해당 콜백함수가 모두 실행될때까지 기다렸다가 나중에 렌더링이 될때 전체적으로 적용된 요소들을 레이아웃 → 페인트에 걸쳐서 브라우저에 표기되기 때문

(⇒ 즉, 어떤 순서로 작성 되어져 있던지 상관없이 자바스크립트 엔진이 콜백안에 들어있는 코드 블럭이 다 완료될때까지 기다렸다가 나중에 랜더링이 발생하기 때문!)

예제2)

```jsx
const button = document.querySelector('button');
const box = document.querySelector('.box');
button.addEventListener('click', () => {
  box.style.transition = 'transform 1s ease-in-out';
  box.style.transform = 'translateX(800px)';
  box.style.transform = 'translateX(500px)';
});
```

⇒ 위와 동일한 이유로, translateX의 값을 바꾸며 얼마나 이동했는지 간에, 결국 렌더링이 발생할때는 최종적으로 transform에 할당된 translateX(500px)가 적용됨 ( 콜백안에서 어떤 변경사항을 설정하던지 상관없이 브라우저에는 변경된 사항이 바로바로 보여지지 않고, 콜백이 끝난 그 다음에서야 브라우저에 업데이트된 사항이 나타나는것 )

<br/>
<br/>

> ### 정리 : 우리가 콜 스텍에 등록하는 함수를 작성할때 오랫동안 일을 하는 것은 좋지 않다. <br>
>
> 왜냐하면 이벤트 루프가 콜 스텍에 오랫동안 머물러 있는 동안 브라우저에게 업데이트가 되지 않고 사용자의 클릭 처리나, 다른 이벤트 처리도 발생하지 않기 때문에 최대한 콜백은 간단하게 작성하는것이 좋고 loop나 while 또는 끝나지 않는 for loop나 재귀함수 같은 것들은 조심해서 사용해야한다.
